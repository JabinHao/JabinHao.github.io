---
title: Chapter5 面向对象(下)
excerpt: static关键字、final关键字、main方法及代码块
tags:
  - java
categories:
  - Java笔记
banner_img: /img/dog.png
index_img: /img/post/Java/java_logo.jpg
abbrlink: e1a4b3a0
date: 2020-10-21 01:25:23
updated: 2020-10-21 01:25:23
subtitle:
# abbrlink: chapter5
---
## 5.1 `static`关键字
可以修饰属性、方法、代码块、内部类

### 1. 属性
* static修饰的属性称为静态属性（类变量），与之相对的是非静态属性（实例变量）
* 相当于类的属性，某个对象修改该属性时，其他对象的该属性也发生变化
* 随着类的加载而加载，早于对象的创建，存在于方法区的静态域中
* 可以直接通过`class.property`调用

### 2. 方法
* 随着类的加载而加载，可以通过`class.method()`调用
* 静态方法中只能调用静态方法或属性
* 静态方法中不能使用`this`、`super`关键字

### 3. 使用场景
* 操作静态属性的方法，通常设置为static
* 工具类中的属性，习惯上声明为static，比如Math、Arrays、Collections

### 4. 单例设计模式
1. 定义  
   指采取一定方法保证整个软件系统中，某个类只能存在一个对象实例
2. 实现方式
   * 饿汉式
   * 懒汉式
3. 单例模式的饿汉式实现
   ```java
   class Order(){
    //1.私有化类的构造器
    private Order(){

    }

    // 2. 内部创建类的静态对象
    private static Order instance = new Order();

    // 3. 提供公共的静态方法，返回类的对象
    public static Order getInstance(){
      return instance;
    }
   }
   ```


4. 单例模式的懒汉式实现
   
   ```java
   class Order(){
     // 1. 私有化类的构造器
     private Order(){

     }
     //2. 声明当前对象，但不初始化（静态对象）
     private static Order instance = null;

     // 3. 声明public、static的返回当前类对象的方法
     public static Order getInstance(){
       if(instance == null){
         instance = new Order();
       }

       return instance;
     }
   }
   ```

5. 两种方式对比
   * 饿汉式
     * 加载时间过长
     * 线程安全
   * 懒汉式
     * 延迟对象的创建

6. 应用场景
   * 网站计数器
   * 应用程序的日志应用
   * 数据库连接池
   * 项目中读取配置的类
   * Application
   * Windows的任务管理器
   * Windows的回收站

## 5.2 `main`方法
### 使用说明
1. 作为程序的入口
2. 也是一个普通的静态方法，可以在程序中调用
3. 可以作为与控制台交互的方式

## 5.3 类的成员四：代码块
1. 结构：一对大括号 `{}`
2. 作用：初始化类、对象
3. 修饰词：只能使用`static`修饰
   * 静态代码块
     * 随着类的加载而加载并执行，只执行一次
     * 初始化类的信息
     * 多个静态代码块时，按顺序执行
     * 静态代码块早于非静态代码块执行
   * 非静态代码块
     * 随着对象的创建而加载执行
     * 每创建一个对象执行一次
     * 可以在创建对象时对其进行初始化
     * 先于构造器执行

## 5.4 `final`关键字
1. 可以修饰类、方法、变量
2. 修饰类，则类不能被继承
3. 修饰方法，则方法不能重写
4. 修饰变量，则变量值不能修改(一般大写)
   * 修饰属性：可以定义后在代码块、构造器中赋值
   * 修饰局部变量
   * 修饰形参：方法内不能修改该变量
5. `static final`: 全局常量

## 5.5 抽象类与抽象方法
### 1. `abstract`关键字的使用
1. 用以修饰类、方法
2. 修饰类：抽象类
   * 此类不能实例化
   * 抽象类中也有构造器
3. 修饰方法：抽象方法
   * 抽象方法只有声明，没有方法体
   * 抽象方法只存在于抽象类中
   * 子类必须重写父类所有抽象方法，才能实例化
   * 抽象方法不能是私有或静态的

### 2. 抽象类的匿名子类
代码实例：  
```java
//假设有抽象类Human
// Human中有抽象方法 growUp()

//匿名子类：
Human p = new Human(){
  // 抽象方法
  public void growUp(){
    // 空
  }
}
```
### 3. 模板方法的设计模式
1. 模板方法  
   在方法中调用抽象方法，子类一般不重写此方法

## 5.6 接口`interface`
### 1. 接口简介
1. 接口使用`interface`关键词定义
2. 接口是与类并列的两个结构

### 2. 定义与使用
1. JDK7 及以前，接口中只能定义**全局常量**和抽象方法
   * 全局常量：`public static final`, 书写时可以省略
   * 抽象方法：`public abstract`，书写时省略则默认
2. JDK8 中，接口可以定义静态方法、默认方法等
3. 接口中不能定义构造器，也就是说接口不能实例化
4. 接口通过类来实现 (`implements`)，若实现类覆盖了接口所有抽象方法，则此实现类可以实例化
5. Java类可以实现多个接口，弥补了Java单继承的缺陷  
   ```java
   class A extends B implements CC, DD
   ```
6. 接口可以继承且支持多继承
7. 接口匿名实现类  
   格式与抽象类匿名实现子类相同

### 3. 注意
1. 可以定义接口指针指向其实现类，方法接口形参可以传入实现类实参
2. **可以在接口中定义其自身实现类的对象**

### 4. 接口的应用
1. 代理模式(Proxy)
2. 工厂模式()

### 5. java8中新特性
1. 静态方法  
   接口中定义的静态方法只能通过接口来调用：`A.method()`
2. 默认方法  
   * 通过实现类可以调用默认方法
   * 重写后调用的是重写后的方法
3. 父类与接口中同名方法，子类默认调用父类方法，调用接口方法可使用 `接口名.super.method();`
4. 多个接口中的同名方法：实现类必须重写该方法，否则报错，接口冲突。
    ```java
    interface A{
      // 静态方法
      public static void play1(){
          // 方法体
      }

      // 默认方法
      public default void play2(){
        // 方法体
      }
    }
    ```

## 5.7 类的内部成员五：内部类
### 1. 定义   
   在类内部定义的类称为内部类
### 2. 分类  
   * 成员内部类：静态、非静态
   * 局部内部类（方法内、代码块内、构造器内）
### 3. 成员内部类
1. 特点
   * 可以被四种权限修饰
   * 可以是静态的
   * 调用外部类属性：`外部类名.this.property`
2. 使用
   * 静态成员内部类定义：`外部类.内部类 p = new 外部类.内部类()`
   * 非静态成员内部类定义：
      ```java
      // 首先实例化外部类
      外部类 p = new 外部类();

      // 通过外部类对象创建内部类对象
      外部类.内部类 p2 = new p.内部类();
      ```